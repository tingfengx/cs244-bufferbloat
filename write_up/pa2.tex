\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{datetime}
\usepackage[T1]{fontenc}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{hyperref}
%\usepackage{natbib}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{multicol} % added package
\usepackage{soul}
\usepackage{tcolorbox}
%\usepackage{caption}
\usepackage[font=footnotesize]{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{pgfplots}
\usepackage[parfill]{parskip}
%\captionsetup{
%	format=hang, 
%    singlelinecheck=false
%}

\titleformat{\section}[runin]
  {\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}[runin]
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}
  
\renewcommand{\thesection}{\Roman{section}} 
\renewcommand{\thesubsection}{\thesection.\Roman{subsection}}

\makeatletter

\renewcommand{\maketitle}{\bgroup\setlength{\parindent}{0pt}
\begin{flushleft}
  \textbf{\Large \@title}\newline
  
  \@author\\
  Date: \@date
\end{flushleft}\egroup
}
\makeatother

\author{Author: Tingfeng Xia, University of Toronto, \url{mailto:tingfeng.xia@mail.utoronto.ca}}
\title{\textbf{Bufferbloat Problem} \\ {\small CSC458 Computer Networks Programming Assignment 2}}

\date{\today}

\begin{document}
\maketitle
\section*{Introduction} 
Bufferbloat refers to the existence of excessively large and frequently full buffers inside a network. \cite{sivov12} 

Most TCP congestion control algorithms rely on packet drops to determine the available bandwidth between two ends of a connection.\cite{allman09, sayad11} In general, TCP congestion control algorithms speed up the data transfer (via increasing congestion window size) until packets start to drop, then slow down the transmission rate. Under ideal conditions, we expect an equilibrium speed to be reached after a period of time of adjustments.

In a fast to slow transition hop, bufferbloat can easily occur. Let's consider the internet topology illustrated in the assignment handout (Assignment Topology). TCP will continue to increase the cwnd size since packets sent out are being buffered inside the intermediate router $s_0$ and with no packet being dropped. It will only decrease the cwnd size when buffer of $s_0$ is saturated, but that is already too late. In other words, the buffer in the intermediate router has turned the packet drops into an \textbf{un-timely} indication of congestion, which is bad since TCP congestion control algorithms rely on timely communication of congestion via packet drops. 

Bufferbloat causes increase in queueing delay, and thus causes end users to experience increase in latency, which is the sum of transmission delay, processing delay, and queueing delay. \cite{sivov12} Bufferbloat also causes jitters and decreases the overall throughput of the network. 
\section*{Methods} 
We emulate our Assignment Topology using mininet. Then, we simultaneously perform the following three tasks
\begin{itemize}
	\setlength\itemsep{-0.5em}
	\item start a long lived TCP flow sending data from $h_1$ to $h_2$, and
	\item send 1 ping per 0.1 second from $h_1$ to $h_2$, and 
	\item spawn an web server on $h_1$, and download the webpage from $h_1$ once every two seconds. 
\end{itemize}
This simulation is repeated for three different queue sizes, $Q = 5 / 20 / 100 $ pkts. Then, for each max queue size, we plot the time-series of the long-lived TCP flow's cwnd, the RTT reported by ping, the webpage download time, and the queue size at the router $s_0$. 

\section*{Results}
Table \ref{tab:mean and std} provides an summary of mean and standard deviation of the fetch time in all three experiments with queue size 5, 20, and 100 pkts respectively, while Figures \ref{fig:buffer5}, \ref{fig:buffer20} and \ref{fig:buffer100} are plotted time-series for the long lived TCP flow's cwnd, RTT reported by ping, webpage fetch time, and queue size at the router. 

%Notice that here (as shown in Table \ref{tab:mean and std}) as the queue size increases, we are seeing an increase in mean fetch time, monotonically. However, this is not the case for the standard deviation of the fetch time. 

\begin{table}
	\center
	\begin{tabular}{|c||c|c|c|}
	\toprule
	Queue Size & 5 & 20 & 100 \\ \midrule \midrule
	Mean(ms) & 0.67010 & 0.75517 & 1.25273 \\ \midrule
	Stddev(ms) & 0.36301 & 0.20127 & 0.62726 \\ \bottomrule
	\end{tabular}
	\captionsetup{format=hang, singlelinecheck=false}
	\caption{\label{tab:mean and std} Mean and standard deviation in fetch time for all three experiments. }
\end{table}
\begin{figure}
	\center\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[width=\textwidth]{../bb-q5/cwnd-iperf}
		\caption{\label{fig:buffer5cwnd}Long-lived TCP flow's cwnd}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{../bb-q5/rtt}
		\caption{\label{fig:buffer5rtt}RTT reported by ping}
	\end{subfigure}
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[width=\textwidth]{../bb-q5/download}
		\caption{\label{fig:buffer5download}Webpage download time}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{../bb-q5/q}
		\caption{\label{fig:buffer5q}Queue size at the router}
	\end{subfigure}
	\captionsetup{format=hang}
	\caption{\label{fig:buffer5}Long-lived TCP flow's cwnd, RTT reported by ping, webpage download time, and queue size at the router with max buffer size of 5. }
\end{figure}
\begin{figure}
	\center\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[width=\textwidth]{../bb-q20/cwnd-iperf}
		\caption{\label{fig:buffer20cwnd}Long-lived TCP flow's cwnd}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{../bb-q20/rtt}
		\caption{\label{fig:buffer20rtt}RTT reported by ping}
	\end{subfigure}
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[width=\textwidth]{../bb-q20/download}
		\caption{\label{fig:buffer20download}Webpage download time}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{../bb-q20/q}
		\caption{\label{fig:buffer20q}Queue size at the router}
	\end{subfigure}
	\captionsetup{format=hang}
	\caption{\label{fig:buffer20}Long-lived TCP flow's cwnd, RTT reported by ping, webpage download time, and queue size at the router with max buffer size of 20. }
\end{figure}
\begin{figure}
	\center\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[width=\textwidth]{../bb-q100/cwnd-iperf}
		\caption{\label{fig:buffer100cwnd}Long-lived TCP flow's cwnd}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{../bb-q100/rtt}
		\caption{\label{fig:buffer100rtt}RTT reported by ping}
	\end{subfigure}
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[width=\textwidth]{../bb-q100/download}
		\caption{\label{fig:buffer100download}Webpage download time}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{../bb-q100/q}
		\caption{\label{fig:buffer100q}Queue size at the router}
	\end{subfigure}
	\captionsetup{format=hang}
	\caption{\label{fig:buffer100}Long-lived TCP flow's cwnd, RTT reported by ping, webpage download time, and queue size at the router with max buffer size of 100. }
\end{figure} 

\section*{Discussion}
As we can see from Figures \ref{fig:buffer5q}, \ref{fig:buffer20q} and \ref{fig:buffer100q}, buffer tend to be full regardless of our queue size choice. Recall that delay is the sum of transmission delay, processing delay, and queueing delay. When the buffer is larger, we are likely to have a larger queuing delay. In the case of fetching a webpage, when $h_1$ sends the webpage file to $h_2$, it is likely that the packet will be queued since it will be travelling from a fast link to a slow one. Thus, the fetch time increases as the buffer size increases. 

When the queue size is 5, the buffer is small. This means that we are unlikely to suffer from bufferbloat problem, but we are more likely to drop packets due to buffer out of space. This explains the high standard deviation for fetch time presented in \ref{tab:mean and std} when queue size is 5. On the contrary, when the queue size is set to 100, we have a high fetch time mean. In this case, bufferbloat is happening. Figure \ref{fig:buffer100q} illustrates the queue occupancy time-series at the router, and we can see that the buffer is unnecessarily full a lot of the time. When the max buffer is at 20, it is more balanced. Although the buffer is also leaning towards the saturated side, since the buffer size is small, we are seeing in Figures \ref{fig:buffer20rtt}, \ref{fig:buffer20download} both faster download time and shorter RTT. Also comparing Figures \ref{fig:buffer5cwnd}, \ref{fig:buffer20cwnd}, \ref{fig:buffer100cwnd} show that as the queue size increase, TCP congestion avoidance algorithm is stepping in less and less. 


%When the queue size is 5, since the buffer is too small, packets get dropped frequently, and this is causing both a high delay and a high variance in this case. On the contrary when the max queue size is 100, the buffer size is too big, and this is causing bufferbloat to happen. Figure \ref{fig:buffer100q} illustrates that this big buffer is frequently (unnecessarily) full and seldomly empty, indicating the bufferbloat problem is occurring. When the max buffer size is 20, however, the buffer is neither too big nor too small; we see the lowest mean fetch time and standard deviation in all three experiments in this case. 

Ipconfig reports a maximum queue length of \texttt{txqueuelen:1000} packets, and a MTU of 1500 bytes. Then, if we have a saturated buffer, we need
\begin{equation}
	(1000 \times 1500 \times 8) / (100 \times 10^6) = 0.12\, \mathrm{second}
\end{equation}

Figure \ref{fig:rtt q relationship} shows\footnote{This plot is generated with my script \texttt{plot\_relationship.py}. However, since I can't submit the file on Markus, I will add it to the appendix of this write up. You will need NumPy and Scipy.stats to run this script, I used them for the fitting of linear regression model.} the three data points that we have, which are pairs of queue size and the average RTT time taken reported by ping. On the plot, the coordinates are marked as text next to the data points. We than fit a linear regression model to our three data points, and then the fitted line is plotted on the same plot. In my case, the fitted line is described algebraically as
\begin{equation}
	\mathrm{RTT (ms)} =  1.71 \times \mathrm{queue Size} + 6
\end{equation}
Also notice that the $p-value$ is very close to zero, $r$ is 1, and the standard error is also very close to zero. This means that we are statistically confident that the linear relationship is described well with our fitted model. 

For the sake of mitigating the bufferbloat problem, we can try 
\begin{itemize}
	\setlength\itemsep{-0.5em}
	\item The probably simplest approach is to decrease the buffer sizes at each hop. This way, when congestion happen, buffers fill up quickly, and then rely on packet drops as a timely indication of congestion. This approach is, however, not optimal. We originally introduced buffers to deal with bursts of packets, and make networking more smooth in general. Reducing buffer size will cost us the ability to deal with bursts in the network. 
	\item Use a delay based congestion avoidance algorithm rather than packet drop based. \cite{sivov12} In this way, if the delay is too high we know that the packet might have been buffered somewhere, signalling a congestion. We can then control the cwnd size based on this information
\end{itemize}

\begin{figure}[]
	\center\includegraphics[width=0.7\textwidth]{../fit}
	\captionsetup{format=hang}
	\caption{\label{fig:rtt q relationship}Scatter plot of RTT (in ms) and the max queue size used respectively. This plot is generated with my script \texttt{plot\_relationship.py}. However, since I can't submit the file on Markus, I will add it to the appendix of this write up. You will need NumPy and Scipy.stats to run this script, I used them for the fitting of linear regression model.}
\end{figure}

\section*{Appendix Code} Figure \ref{code} is the code used to produce Figure \ref{fig:rtt q relationship}. 
\begin{figure}[H]
\center
\begin{tcolorbox}[title=Source Code \texttt{plot\_relationship.py}]
  %add special color box to list of listings
  \makeatletter
  \addcontentsline{lol}{subsection}{\kvtcb@title}
  \makeatother

\begin{multicols}{2}
	\begin{minted}[fontsize=\tiny]{python}
import matplotlib.pyplot as plt
import numpy as np
from scipy import stats

def get_ping_vals(filename):
	with open(filename, 'r') as f:
	    lines = f.readlines()
	    ret = []
	    num = 0
	    for line in lines:
	        if 'bytes from' not in line:
	            continue
	        try:
	            rtt = line.split(' ')[-2]
	            rtt = rtt.split('=')[1]
	            rtt = float(rtt)
	            ret.append(rtt)
	        except:
	            break
	    return np.array(ret)

plt.figure(figsize=(8, 6))
# plt.style.use("seaborn")
qs = np.array([5, 20, 100])
filenames = ["./bb-q5/ping.txt", "./bb-q20/ping.txt", "./bb-q100/ping.txt"]
rtts = np.array([np.mean(get_ping_vals(i)) for i in filenames])

slope, intercept, r_value, p_value, std_err = stats.linregress(qs, rtts)
plt.scatter(qs, rtts, s=100, label="Observations")
for x, y in zip(qs, rtts):
text = '(' + str(x) + ', {:.2f})'.format(y)
plt.text(x - 10, y - 10, text)

plt.plot(
np.arange(0, 101), 
np.arange(0, 101) * slope + intercept, 
label="Fitted Line via Linear Regression \n$RTT$" + 
      "$= {:.2f} + {:.2f} \\times qsize$\np-val = {:.2f}, r = {:.2f}, stderr = {:.2f}".format(
          intercept, slope, p_value, r_value, std_err)
)

plt.title("Relatinship between RTT and Queue size", size=18)
plt.xlabel("queue size", size=14)
plt.ylabel("rtt time in average (ms)", size=14)
plt.legend(loc="best")
plt.savefig("./fit.pdf")
	\end{minted}
\end{multicols}
\end{tcolorbox}
\captionsetup{format=hang, singlelinecheck=false}
\caption{\label{code}Appendix Code, \texttt{plot\_relationship.py}. I was not able to include this file to MarkUs submission, so I am including it here in Appendix. It produces Figure \ref{fig:rtt q relationship}. Sorry for the small font size, I had to fit this inside 5 pages limit. }
\end{figure}


\bibliographystyle{apalike}
\bibliography{bib.bib}

\end{document}
